---
layout: post
title:  "连接器的初学者指南"
date:   2020-4-12 12:15:03 -0400
category: 编译器
---

这部分是介绍 C文件的不同部分，如果你熟悉下列代码，可以进入下一部分。

第一步需要区分理解 申明(declarations) 和 定义(definitions),
 定义关联一个名字并且有代码或者数据来实现这个名字：

	1. 定义一个变量，让编译器给该变量分配空间，可能给这个空间分配一个值。
	2. 定义一个函数，让编译器给这个函数产生代码。

 声明告诉 C 编译器在当前程序中有这个定义，可能在别的 C 文件中。（注意定义有时会看成声明，当其位置在声明的地方时）。

 对于变量，有两种类型定义：

 	1. 全部变量，存在于整个程序的生命周期中("static extent")，在很多不同的函数中可以获取到。
 	2. 局部变量，仅存在于一个特定的函数中("local extent")，仅通过这个函数才能获取到这个变量。
 	(这里的获取，是说可以引用这个变量)

	这里有两个特例：
	
		1. 静态局部变量，实际上是全部变量，因为它存在于整个生命周期，但只能从这个特定函数获取。
		2. 同样的静态全局变量也可以看成全局变量，虽然只能在它定义的 C文件中获取到。
	这里我们把焦点放在了关键字 "静态(static)" 上，需要指出的是将一个函数变为静态函数，可以减少其他地方引用该函数的行数(特别是通过同一个 C文件的不同函数) -> 此处我的理解是函数的定义被共享了，不会在引用的地方再展开函数

	通过比较全局变量和局部变量的定义，我们能区分出变量在哪里初始化(在那里地方空间和名字关联，变量被分配一个值)哪里没有初始化。 

最后，我们可以通过 malloc 或者 new 把信息动态地存储到内存，没有办法通过名称直接访问分配的内存，所以我们必须通过指针(一个命名变量保留着一段内存地址)。这个内存地址可以通过 free or delete 来销毁，所以这被引用的空间有个动态的范围(dynamic extent)。

总结一下：
<图片>

<实例>


C 编译器做了什么

C 编译器的任务是将人们可读的代码翻译为机器可理解的代码。编译器的输出为目标文件(Object file)。在 UNIX 平台这些目标文件通常以 .o 结尾，Windows 上以 .obj 结尾。目标文件的内容是基础的两类东西：
	1. 代码 C 文件中响应的函数定义
	2. 数据 C 文件中全局变量的定义(对于初始化的全局变量，初始值已经保存在目标文件中了)

这两种类型的实例，都有名字与其关联(变量和函数的名字是在定义的时候产生的)。

目标文件代码是一系列的机器指令，和程序员写入的 C 指令相关联(if /while /goto)。所有这些指令需要根据信息进行分类，这些信息需要保存下来(这是变量的工作)。这些代码也有可能引用其他的一些代码，特别是程序中其他的 C函数。
在任何地方，代码能够引用一个变量或者函数，编译器必须提前看到这个变量或者函数的声明(声明约定了定义存在于整个程序的某个地方)。

连接器的任务就是遵守这些约定，但编译器是怎样在生成目标文件的同时处理所有的约定的呢？

简单来讲，编译器会留下一个空缺。这个空缺(一个引用)有一名字与之关联，但这名字所对应的值未知。

我们可以描述上个示例的引用关系如下：

<图片>

剖析一个目标文件

到目前为止，我们都是在上层来分析的；但看看在实际中底层如何工作这也很重要。用到的关键工具是 nm ,用它可以获取 NUIX 平台一个目标文件的标记(symbols)信息。Windows平台可以用 dumpbin 带上 /symbols 来大致产生相同的效果；这里也有提供了一个 Windows 版本的 nm 工具 <连接>

让我们看看通过 nm 工具获取到上面示例目标文件的信息：
<图片>

不同平台下的输出会有一点点不同(查看 nm 的 pages 页可以查找出版本的特性)，但是关键每个 symbol 的关键信息是 class 和它的 size(如果有的话)，class有不同的值：

1. “U” 是指未定义的引用，上文说的编译器留出的空缺是其中一种。在这个目标文件中，有两个 "U" 类型 "fn_a" 和 "z_global"。(一些 nm 版本可能会打印一个词语，如 "*UND*" 或者 “UNDEF”)
2. "t" "T" 是指这个函数定义了，“t” 是说函数定义在同一个文件下，“T”是说函数定义在其他文件下(函数初始定义的地方是静态的"static")。(同样，一些系统下会显示为一个词语, 如 ".text")
3. "d" "D" 是指初始化的全局变量，同样 "d" 是定义在同一个文件下，"D"是定义在其他文件下("static")。( ".data")
4. "b" "B" "C" 是指未初始化的全局变量，静态的或者本文件中的是 "b", B 和 C 是其他的。(".bss" "*COM*")

我们可能获取到的一些 Symbols 不是 C文件原始出入的一部分；我们将会忽略这些 Symbols，把它们视为编译器内部机制产生的试图获取我们程序的恶意链接。

连接器做了什么？第一部分

我们在之前提过，声明一个函数或者变量就是给 C编译器达成一个约定，在程序的某个地方有这个函数或者变量的定义，链接器的作用就是达成这个约定。通过前面的目标文件图，我们可以进一步说明填充空缺。

为了阐述填充空缺，我们再增加一个 C文件：
<图片>

讲这两幅图放一起，我们能够将所有的节点连接起来(如果存在连接不上的点，链接器会报错)。每个事物都有它自己的位置，每个位置都有它自己的事物，而链接器可以填充所有的空缺，如图所示：
<图片>

我们可以通过 nm 指令来查看这两个目标文件链接后的信息：
<图片>

所有的符号(Symbol)来自这两个目标文件，所有的未定义引用都没有了。这些 也都进行了重新排序，以便将相似类型的事物放在一起，并添加了一些附加功能，以帮助操作系统将整个事物作为可执行程序处理。
(还有很多复杂的细节使输出杂乱无章，但是如果您滤除任何以下划线开头的内容，它将变得更加简单。)

重复的符号

上部分中有提到如果链接器找不到符号的定义，就会报错。但是如果在连接时有两个不同的定义对应一个符号呢？

在 C++ 中，这场景的处理很直接。这语言有严格的一个定义对应一个符号的规则，在连接时只能有一个定义与符号对应，不能多也不能少。(C ++标准的相关部分是3.2，其中还提到了一些例外情况，我们将在以后介绍。)

在 C 语言中，这个规则有些模糊。任何函数或者初始化的全局变量必须有明确的定义，但是未初始化的全局变量可以视为临时定义。C 语言允许(或者不禁止)不同的源文件有对一个符号的临时定义。

然而链接器除了处理 C 和 C++ 外还要处理其他语言，这些语言不一定适用一个定义对应一个符号的规则。例如：Fortran语言的普通模型是将全局变量拷贝到引用到它的每个文件中，链接器要求选择其中一个拷贝(如果他们大小不一，选择其中最大的)，将其他重复的折叠起来抛弃。(这个模型被称为链接器的共用模型，以 Fortran 的关键字 "COMMON" 命名)

因此，对于UNIX连接器来说，至少在重复符号是未初始化的全局变量时，它们通常不会抱怨符号的重复定义(这有时被说成是连接的“宽松声明/定义模型”)。如果你担心这个问题，查阅链接器的手册通常有 "--work-properly"选项来严格限制重复定义的行为。例如：GUN 工具链就有 "-fno-common" 选项将未初始化的变量放在 BBS 段(BBS segment) 而不是 Common 块(BBS block)。

操作系统做了什么？

现在链接器已经将所有的符号引用都连接到了对应的定义，生成了一个可执行程序，我们需要暂停一会儿来简明的说明在程序运行的时候，操作系统所扮演的角色。

运行程序显然涉及执行机器代码，所以操作系统必须将磁盘上的可执行文件翻译为机器代码送入CPU可读取的地方--计算机内存。程序被送入内存的部分被命名为代码段(code segment)或者文本段(text segment)。

没有数据的代码什么也不是，所以全部的全局变量也要被送入计算机内存。然而初始化和未被初始化的全局变量是有区别的。初始化的全局变量有初始值保存在之前的目标文件和可执行文件中。当程序执行起来，操作系统会将这些值拷贝到内存的数据段(data segment)。对于未被初始化的全局变量，操作系统假设它们的初始值为 0，没有必要拷贝任何值。这些初始化为0的内存块称为bss段(BBS segment)。

这意味着可以将空间保存在磁盘上的可执行文件中。 初始化变量的初始值必须存储在文件中，但是对于未初始化变量，我们只需要计算它们需要多少空间即可。
<图片>

读着也许注意到，前面我们所讨论的目标文件和链接器只涉及到了全局变量，并没有讨论过局部变量和动态分配的内存(指针对象)。

其实这些数据的分配并不需要任何链接器的参与，因为它们的生命周期发生在程序的运行时(run time)，在链接器完成了它的工作之后。问了文章的完整性，在这里简单的介绍一下：

1. 局部变量被分配在栈内存上，栈内存随着函数的调用和完成，增长或者减小。
2. 动态分配的内存受到堆内存管理，malloc 函数在这个区域内搜索可用的空间。

我们把这部分内存分配加入到图中，完成在程序运行时刻的内存分配模型。因为堆和栈在程序运行时大小是会随时改变的，通常安排堆往一个方向扩展内存，栈往另外一个方向。通过这种方式，程序只会在这两端相遇时耗尽内存(此时，内存空间已经满了)
<图片>

翻译中：http://www.lurklurk.org/linkers/linkers.html